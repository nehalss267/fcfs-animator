<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FCFS Scheduling Animator</title>
    <link rel="stylesheet" href="style.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f7f6;
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            padding: 25px;
            margin-bottom: 20px;
        }

        h1, h3 {
            color: #0056b3;
            text-align: center;
        }
        h3 { text-align: left; }

        /* Form Styling */
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .form-group input {
            width: 100%;
            padding: 8px;
            box-sizing: border-box; /* Important for padding */
            border: 1px solid #ccc;
            border-radius: 4px;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
        }
        button:hover {
            background-color: #0056b3;
        }
        #reset-btn {
            background-color: #dc3545;
        }
        #reset-btn:hover {
            background-color: #a02734;
        }

        /* Table Styling */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        table th, table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: center;
        }
        table th {
            background-color: #007bff;
            color: white;
        }

        /* Gantt Chart Styling */
        #gantt-chart-container {
            width: 100%;
            background-color: #eee;
            border-radius: 4px;
            padding: 10px;
            overflow-x: auto;
            position: relative;
            min-height: 100px;
        }

        #gantt-chart {
            display: flex;
            flex-direction: row;
            position: relative;
            height: 60px;
        }

        /* This is the animated process block */
        .gantt-block {
            height: 100%;
            position: absolute; /* We use absolute positioning for animation */
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            border: 1px solid #333;
            box-sizing: border-box;
            /* transition for smooth width change */
            transition: width 0.5s ease-in-out, left 0.5s ease-in-out;
        }

        #timeline {
            display: flex;
            position: relative;
            height: 20px;
            margin-top: 5px;
        }
        .time-marker {
            position: absolute;
            font-size: 12px;
            color: #555;
            transform: translateX(-50%); /* Center the text */
        }

        #results p {
            font-size: 1.1em;
            background: #e6f7ff;
            border: 1px solid #b3e0ff;
            padding: 10px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <h1>FCFS Scheduling Algorithm Animator</h1>

    <div class="container">
        <h3>Add Process</h3>
        <form id="process-form">
            <div class="form-group">
                <label for="arrival-time">Arrival Time:</label>
                <input type="number" id="arrival-time" min="0" value="0" required>
            </div>
            <div class="form-group">
                <label for="burst-time">Burst Time:</label>
                <input type="number" id="burst-time" min="1" value="1" required>
            </div>
            <button type="submit">Add Process</button>
        </form>
    </div>

    <div class="container">
        <h3>Process List</h3>
        <table id="process-table">
            <thead>
                <tr>
                    <th>Process ID</th>
                    <th>Arrival Time</th>
                    <th>Burst Time</th>
                </tr>
            </thead>
            <tbody>
                </tbody>
        </table>
        <button id="run-btn">Run FCFS</button>
        <button id="reset-btn">Reset</button>
    </div>

    <div class="container">
        <h3>Gantt Chart</h3>
        <div id="gantt-chart-container">
            <div id="gantt-chart"></div>
            <div id="timeline"></div>
        </div>
        
        <h3>Results</h3>
        <div id="results">
            </div>
    </div>

    <script >
        document.addEventListener('DOMContentLoaded', () => {
    // Get HTML Elements
    const processForm = document.getElementById('process-form');
    const processTableBody = document.querySelector('#process-table tbody');
    const runBtn = document.getElementById('run-btn');
    const resetBtn = document.getElementById('reset-btn');
    const ganttChart = document.getElementById('gantt-chart');
    const timeline = document.getElementById('timeline');
    const resultsDiv = document.getElementById('results');

    let processList = [];
    let processIdCounter = 1;
    const TIME_SCALE = 30; // 30 pixels per unit of time

    // 1. Add Process Event Listener
    processForm.addEventListener('submit', (e) => {
        e.preventDefault();
        const arrivalTime = parseInt(document.getElementById('arrival-time').value);
        const burstTime = parseInt(document.getElementById('burst-time').value);

        if (isNaN(arrivalTime) || isNaN(burstTime) || burstTime <= 0) {
            alert("Please enter valid Arrival Time and Burst Time (Burst > 0).");
            return;
        }

        const process = {
            id: `P${processIdCounter++}`,
            arrival: arrivalTime,
            burst: burstTime,
            color: getRandomColor()
        };

        processList.push(process);
        addProcessToTable(process);

        // Reset form
        processForm.reset();
        document.getElementById('arrival-time').value = 0;
        document.getElementById('burst-time').value = 1;
    });

    // 2. Run FCFS Event Listener
    runBtn.addEventListener('click', runFCFS);

    // 3. Reset Event Listener
    resetBtn.addEventListener('click', resetAll);

    function addProcessToTable(process) {
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${process.id}</td>
            <td>${process.arrival}</td>
            <td>${process.burst}</td>
        `;
        processTableBody.appendChild(row);
    }

    // 4. The Core FCFS Logic and Animation
    async function runFCFS() {
        if (processList.length === 0) {
            alert("Please add at least one process.");
            return;
        }

        // FCFS Algorithm: Sort by arrival time
        processList.sort((a, b) => a.arrival - b.arrival);

        // Clear previous results
        ganttChart.innerHTML = '';
        timeline.innerHTML = '';
        resultsDiv.innerHTML = '';

        let currentTime = 0;
        let totalWaitingTime = 0;
        let totalTurnaroundTime = 0;
        const ganttData = []; // To store animation info

        for (const process of processList) {
            // Check for idle time
            if (currentTime < process.arrival) {
                const idleTime = process.arrival - currentTime;
                ganttData.push({
                    id: 'Idle',
                    start: currentTime,
                    duration: idleTime,
                    color: '#555'
                });
                currentTime = process.arrival;
            }

            // Process execution
            const completionTime = currentTime + process.burst;
            const turnaroundTime = completionTime - process.arrival;
            const waitingTime = turnaroundTime - process.burst;

            totalWaitingTime += waitingTime;
            totalTurnaroundTime += turnaroundTime;

            // Store data for animation
            ganttData.push({
                id: process.id,
                start: currentTime,
                duration: process.burst,
                color: process.color
            });

            currentTime = completionTime;
        }

        // Now, animate the Gantt chart
        await animateGanttChart(ganttData);

        // Finally, display results
        displayResults(totalWaitingTime, totalTurnaroundTime);
    }

    // 5. Animation Function
    async function animateGanttChart(ganttData) {
        let maxTime = 0;
        for (let i = 0; i < ganttData.length; i++) {
            const data = ganttData[i];
            const blockWidth = data.duration * TIME_SCALE;
            const blockLeft = data.start * TIME_SCALE;

            // Create the block
            const block = document.createElement('div');
            block.classList.add('gantt-block');
            block.innerText = data.id;
            block.style.backgroundColor = data.color;
            block.style.width = '0px'; // Start with 0 width
            block.style.left = `${blockLeft}px`;
            
            // Add block to chart
            ganttChart.appendChild(block);

            // Animate the width (this is the magic)
            await new Promise(resolve => setTimeout(resolve, 100)); // Short delay
            block.style.width = `${blockWidth}px`;

            // Add time markers
            addTimeMarker(data.start);
            maxTime = data.start + data.duration;
            
            await new Promise(resolve => setTimeout(resolve, 500)); // Wait for animation
        }
        addTimeMarker(maxTime); // Add final time marker
    }
    
    function addTimeMarker(time) {
        const marker = document.createElement('div');
        marker.classList.add('time-marker');
        marker.innerText = time;
        marker.style.left = `${time * TIME_SCALE}px`;
        timeline.appendChild(marker);
    }

    // 6. Display Results Function
    function displayResults(totalWaitingTime, totalTurnaroundTime) {
        const avgWaitingTime = totalWaitingTime / processList.length;
        const avgTurnaroundTime = totalTurnaroundTime / processList.length;

        resultsDiv.innerHTML = `
            <p><strong>Average Waiting Time:</strong> ${avgWaitingTime.toFixed(2)}</p>
            <p><strong>Average Turnaround Time:</strong> ${avgTurnaroundTime.toFixed(2)}</p>
        `;
    }

    // 7. Reset Function
    function resetAll() {
        processList = [];
        processIdCounter = 1;
        processTableBody.innerHTML = '';
        ganttChart.innerHTML = '';
        timeline.innerHTML = '';
        resultsDiv.innerHTML = '';
        document.getElementById('process-form').reset();
    }

    // Utility to get random colors
    function getRandomColor() {
        const letters = '0123456789ABCDEF';
        let color = '#';
        for (let i = 0; i < 6; i++) {
            color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
    }
    });
    </script>
</body>

  </html>
  
